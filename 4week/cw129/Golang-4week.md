# 24장

## Goroutine

    Golang의 동시성이 특출난 이유, 다른 언어와는 다르게 CPU 코어마다 OS 스레드를 하나씩 할당하여 컨텍스트 스위칭에 대한 비용이 발생하지 않음
    Go 런타임에서 논리적(가상)으로 관리함

## Goroutine과 Thread의 차이
    1. 메모리 소비
        Goroutine은 생성할 때 많은 메모리가 필요하지않음, (2kb의 스택 메모리만 사용하며 필요에따라 힙메모리도 사용
        Thread는 생성시 쓰레드가 사용할 메모리 공간을 격리하기 위해 Guard Page라는 메모리 영역을 포함하여 1mb를 사용
    2. 생성/소거 비용
        다른 언어의 Thread는 OS 쓰레드를 할당, 즉 OS에서 자원을 할당, 반납하는 과정이 필요(하드웨어에 일정 부분 의존)
        Goroutine은 Go런타임에서 논리적으로 처리하여 비용이 저렴
    3. Context Switching 비용
        일반적인 Thread Context Switching : 
          16개의 범용 레지스터, PC(Program Counter), SP(Stack Pointer), Segment 레지스터, 16개의 XMM레지스터, FP coprocessor state, 16개의 AVX 레지스터, 모든 MSR들 등을 save/restore
        
        Goroutine : 3개의 레지스터(PC,SP,DX)만 save/restore

## Thread
    User-Level 쓰레드 : 여러 User-Level 쓰레드가 1개의 OS 쓰레드 위에서 동작하는 형태(즉, 1:N)
                      OS Thread를 하나만 사용하여 멀티 코어를 사용할 수 없음
    Kernel-Level 쓰레드 : Kernel이 쓰레드의 생성, 스케줄링을 관리(1:1)
                        멀티 코어 활용이 가능하나 성능이 저하됨
    Combined : Kernel-Level 쓰레드와 User-Level 쓰레드를 혼합하여 사용(M:N)
               구현이 어렵다는 단점이 있으나 Golang은 런타임에서 처리하여 간단하게 사용가능

## Go 스케줄러
    Go 스케줄러가 고루틴의 스케줄링 작업을 수행
    GMP 모델(구조체)
![image](https://github.com/CW129/go_lang_study/assets/104714337/0b22e637-fd49-4ecc-ae83-36af222ce3f7)
    
# 25장
## 채널
    채널 : 고루틴끼리 메시지를 전달할수 있는 메시지 큐
          크기가 0인 채널을 사용할 경우, 데이터를 저장할 공간이 없어 데이터를 누군가 추출하기 전에는 고루틴이 중지됨
          버퍼를 사용할 경우에도 버퍼의 용량이 다 차면 버퍼에 공간이 생길때까지 중지됨

    Select 문 : 채널에서 데이터가 들어오길 대기하는 상황에서 다른 작업을 처리하기 위해 사용
<img width="502" alt="image" src="https://github.com/CW129/go_lang_study/assets/104714337/18061fd9-02bd-4be6-a7df-2d036e58211d">
    하나의 채널에서 데이터를 읽어오고 해당 구문 종료, 모든 채널의 데이터를 읽어오고싶으면 반복문과 함께 사용

## 컨텍스트
    컨텍스트 : 작업에 관련된 데이터(설정 등)을 지시하는 기능
             OS 레벨에서 하는 컨텍스트 스위칭을 런타임 레벨에서 제어할 수 있게하는 패키지

# 28장
## 테스트 코드
    Golang은 테스트 코드 작성과 실행을 언어 자체에서 지원
      1. 파일명은 _test.go로 끝나야함
      2. testing 패키지를 임포트 해야함
      3. 테스트 코드는 함수로 묶어야하며 함수명은 Test로 시작해야함

## 블랙박스 테스트 (명세 기반)
    1. 동등 분할 기법(Equivalence Partitioning)
        입출력 데이터에 따라 다르게 동작하는 기능 테스트에 사용되는 기법
    2. 경계값 분석 기법(Boundary Value Analyze)
        경계가 있는 입력 데이터에 따른 동작을 검사하는 기법(입력값 경계를 초과한 데이터를 입력)
    3. 오류 예측 기법(Error Guessing)
        각 기능의 제약조건을 위반하는 동작을 하여 오류가 발생하는지 검사하는 기법
    4. 원인 결과 그래프 기법(Cause Effect Graph)
        원인-결과를 그래프를 통해 논리적 관계로 표현하고 이를 기반으로 테스트 케이스 작성
    5. 의사결정 테이블 테스팅
        입력 조건과 결과를 참,거짓으로 표현해 케이스를 조합하는 기법
    6. 상태전이 테스팅
        시스템의 상태가 변화함에 따라 다른 결과가 도출될떄 그 과정을 테스트케이스로 작성

## 화이트박스 테스트 (구조 기반)
    1. 문장 검증
        프로그램 코드 전체가 실행 되는지 검증
    2. 분기 검증
        모든 분기를 최소 한번은 실행하게 하는 방식
    3. 경로 검증
        각각의 조건이 모두 참/거짓을 한번씩은 실행하게 하는 방식
    4. 조건 검증
        조건문의 모든 조건식을 한번은 실행하게 하는 방식



    *테스팅의 7가지 원리
    1. 결함이 존재함을 밝히는 활동, 결함이 없음을 밝히는게 아님
    2. 완벽한 테스팅은 불가능
    3. 조기 테스팅으로 시간과 비용 절약
    4. 결함은 집중되어 나타남( 소수의 모듈에 집중되어 발생하는 경향 )
    5. 살충제 패러독스 ( 새로운 결함을 발견하기 위해선 기존 테스트만을 하면 안됨)
    6. 테스팅은 정황에 의존
    ex) 안전 최우선 산업에의 제어 소프트웨어는 이커머스 애플리케이션과 다르게 테스트해야함
    7. 오류 부재는 궤변이다.
    (단순히 많은 결함을 발견하고 고쳤거나, 결함이 거의 없다고해서 시스템의 성공이 보장되는게 아님)
