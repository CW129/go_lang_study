# 8장

##  iota 활용법
    type Day int

    const (
        SUN Day = iota
        MON
        TUE
        WED
        THU
        FRI
        SAT
    )
    
    func (day Day) String() string{
    return []string{"sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"}[day]
    }
    
    func main() {
    fmt.Println(SUN)
    }

    위의 형태로 String 메소드를 오버라이드하여 상수에서 원하는 문자열 출력도 가능
    * type 키워드에 타입명의 첫 글짜가 대문자이면 외부 패키지 외부로 공개되는 타입
    
## 상수와 리터럴

    상수는 컴파일시 리터럴로 전환되어 실행 파일의 값 형태로 실행 -> 프로그램 메모리 로드시 코드 영역에 포함됨(동적 할당 메모리 영역 사용X)
    
# 9장

## if
    Go의 if문은 쇼트 서킷을 사용함으로 우변의 조건문이 실행되지 않을 경우를 주의해야함
<img width="376" alt="image" src="https://github.com/CW129/GOLANG_study/assets/104714337/4a079b82-e21a-484f-8826-da1d04fd17f0">

    if 초기문; 조건문을 사용하여 함수를 통한 조건도 사용할 수 있다
    함수의 bool 리턴값으로 true/false 조건
    
# 10장
    
## const 열거값과 switch문
    switch문 보단 메소드 오버라이딩을 통해 상수 열거값으로 수행하는 로직을 더 많이 사용함
    switch문은 default case가 있어 상수 열거값에 없는 케이스도 실행 가능
    Go의 switch문은 해당하는 case 실행 후 자동으로 break(하위 case 실행 안함), fallthrough 키워드를 통해 다음 case도 실행 할 수 있음
    
# 11장

## for문 형태
    기본 형태 :
    for 초기문; 조건문; 후처리{
    }
    초기문 생략 :
    for; 조건문; 후처리{
    }
    후처리 생략 :
    for 초기문; 조건문{
    }
    초기문, 후처리 생략:
    for 조건문{
    }
    무한루프 :
    for {
    }
    
## continue && break
    continue: 코드 블록을 실행하지 않고 후처리 실행
    break: for문을 종료

## for문을 중지하는 방법
    1. 조건을 벗어남
    2. break 키워드
    3. 플래그 변수
        bool 타입의 변수로 true, false 값을 확인하여 중지   
    4. for문 레이블
        break는 자신이 속한 for문만 종료함, 중첩 for문에선 for문에 레이블을 사용하여 모든 for문을 종료할 수 있음
        label:
            for {
                for{
                    if a < 10{
                        break label
                    }
                }
            }
    레이블은 코드에 혼동을 줄 수 있음으로 되도록 플래그 변수를 사용(플래그와 레이블 사용은 최소화)

# 12장

## 배열의 메모리 처리
<img width="430" alt="image" src="https://github.com/CW129/GOLANG_study/assets/104714337/6923bc66-0431-4857-962e-12d0a7ff034e">

    배열 선언시 메모리의 연속된 공간을 확보(지정한 타입의 지정된 인덱스 개수만큼 저장할 수 있는 공간)
    컴퓨터에선 배열의 요소를 찾을때 배열의 (타입 크기 * 인덱스)로 주소를 찾음
    다중 배열은 전체 요소 개수만큼 연속된 메모리 형태로 저장
    
# 구조체

    Go의 구조체는 필드의 집합(메소드 X)
    고유의 방식으로 객체지향을 지원(Go는 클래스, 객체, 상속 개념이 없음)
    일반적인 객체지향의 클래스는 필드와 메소드를 가지고 있고, Go에서는 필드와 메소드를 분리하여 관리함

## 구조체에 구조체 포함
    2가지 방식
    1. 기본적인 내장 타입처럼 포함
    2. 포함된 필드 방식(embeding)
        상속처럼 사용이 가능함
        두 구조체의 메소드명이 같을 경우, 자식 구조체의 메소드가 오버라이딩된다
        부모의 메소드를 호출하고싶은 경우 자식.부모.메소드() 형식으로 불러오면됨
     
## 메모리 정렬
    컴퓨터는 데이터에 효과적으로 접근하기 위해 메모리를 일정 크기 간격으로 정렬
    32bit의 레지스터가 한번에 연산 = 4바이트
    64bit의 레지스터가 한번에 연산 = 8바이트
    메모리 패딩: 메모리 정렬을 위해 일정 바이트 공간을 띄움 (4바이트 변수는 4의 배수, 2바이트는 2의 배수)
    
    * 즉 구조체에선 이 부분을 신경쓰며 타입의 순서를 지정해야 메모리 낭비를 줄일 수 있
# 13장

## 스택과 힙 메모리
    대부분의 언어는 함수 내부에서 사용하는 메모리를 스택 영역에 할당
    C는 malloc 함수로 힙영역 할당, 자바는 클래스 타입은 힙, 기본 타입은 스택으로 할당
    Go 언어는 탈출 검사를 통해 인스턴스가 함수 외부로 공개되는 경우 자동으로 힙 영역으로 할당
    
 # 16장
    main() 패키지 - 프로그램의 entry point
    패키지 이름은 별칭을 주어 사용할 수 있음
    사용하지 않는 패키지는 에러가 발생됨 - 패키지명 앞에 밑줄을 주면 예외처리 가능(패키지를 직접 사용하지 않을 경우 사용)
    
Golang 참고 
https://refactoring.guru/ko/design-patterns/go
