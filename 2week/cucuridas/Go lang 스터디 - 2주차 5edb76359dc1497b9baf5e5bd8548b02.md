# Go lang 스터디 - 2주차

# 중요 포인트

### 상수로 사용할 수 없는 타입들 - p.176

1. **타입에 따라 값이 런타임에 결정되는 타입**: Go 언어의 상수는 **컴파일 시점에 값을 결정**하므로, 런타임에 결정되는 값은 상수로 표현할 수 없습니다. 이는 동적으로 크기가 결정되는 배열, 맵, 슬라이스 등의 타입을 포함합니다.
2. **인터페이스 타입**: 인터페이스는 **런타임에 값의 타입이 결정**되므로, 상수로 표현할 수 없습니다. 인터페이스 변수에는 다양한 타입의 값이 들어갈 수 있기 때문에 컴파일 시점에 값을 결정할 수 없습니다.
3. **함수 타입**: 함수는 일급 객체로서 변수에 할당되거나 매개변수로 전달될 수 있습니다. 함수 타입은 런타임에 동적으로 결정되므로, 상수로 표현할 수 없습니다.


📌 일급 객체란<br>
	컴퓨터 프로그래밍 언어 디자인에서, 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 인자로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다



### if - 쇼트 서킷 -p.192

&& 연산은 좌변이 false이면 우변을 검사하지 않고 fasle 처리 || 좌변이 true이면 우변은 검사 없음 true 리턴

```go
if false && IncreaseAndReturn() <5 {
	// 바로 false 이기에 IncreaseAndReturn 함수 실행 X

}

if true || IncreaseAndReturn() <5 {
	// 바로 true 이기에 IncreaseAndReturn() 함수 실행 X
}
```

### if - 초기문; 조건문 -p.194

초기문을 통해 초기화를 진행한 뒤 조건문을 통해 if 구문을 동작

```go
if filename, success := UploadFile(); success {
	fmt.Println("Upload success",filename)
} else {

	fmt.Println("Failed to upload")
}
```

### switch 문과 if 문을 사용할 떄 tip

1. **단순한 값 비교**: switch 문은 여러 값에 대한 비교를 한 번에 처리할 수 있으므로, 여러 개의 if 문을 사용하는 것보다 가독성과 성능 면에서 더 유리할 수 있음
2. **범위나 복잡한 조건**: if 문은 복잡한 조건을 다룰 수 있으며, 범위를 확인하는 경우에도 유용합니다. switch 문은 값에 대한 정확한 일치를 확인하는데 주로 사용되므로, 범위나 복잡한 조건을 다루기에는 제한적일 수 있음
3. **코드 가독성**: 가독성은 코드의 이해와 유지보수에 중요한 요소입니다. switch 문은 여러 값에 대한 처리를 한 곳에 모아놓을 수 있어 가독성이 높을 수 있습니다. if 문은 각각의 조건이 분리되어 있기 때문에 각 조건의 의도를 명확하게 표현 가능

### switch 초기문 - p.208

if 문과 마찬가지로 초기문을 통해 데이터를 초기화 후 판별 가능

```go
switch age := getMyAge(); age {
case 10:
	fmt.Println("Teenage")
case 33:
	fmt.Println("Pair 3")
defult:
	fmt.Println("My age is",age)

}
```

### switch break와 fallthrough 키워드 - p.212

case 안에 break를 넣지 않아도 종료됨, fallthrough 키워드를 통해 다음 항목까지 출력

```go
a: = 3

switch a {
case 3:
	fmt.println("3")

case 4:
	fmt.println("4")
}
// 3과 4 출력
```

### 반복문의 형태

초기문 정의 → 조건문에 의해 확인 → 코드불록 수행 → 후처리 (해당 과정을 반복)

```go
for 초기무니 조건문; 후처리 {
	코드 블록 // 조건문이 true인 경우 수행
}
```

### 반복문과 메모리와의 관계

1. 반복 변수의 스코프(범위,접근): Go 언어의 for 문에서 반복 변수는 해당 반복문 블록 내에서만 유효합니다. 이는 반복 변수의 스코프를 제한하여 메모리 사용을 최소화합니다. 반복문이 종료되면 반복 변수는 자동으로 해제되어 메모리를 확보합니다.
2. 레이스 컨디션 방지: Go 언어의 for 문에서는 반복 변수를 매 반복마다 새로운 메모리 위치에 할당합니다. 이는 다중 고루틴 환경에서 발생할 수 있는 레이스 컨디션(Race Condition)을 방지하기 위한 조치입니다. 각 반복에서 독립적인 메모리 위치를 사용하므로 다른 고루틴과의 메모리 충돌을 피할 수 있습니다.
3. 배열과 슬라이스 반복: Go 언어에서는 반복문을 사용하여 배열과 슬라이스를 반복할 수 있습니다. 이 때 반복문은 인덱스와 해당 요소의 값을 별도로 할당하지 않고, 배열 또는 슬라이스의 메모리 위치를 참조하여 반복합니다. 이는 반복 동안 새로운 메모리를 할당하지 않으므로 메모리 효율적인 반복이 가능합니다.
4. 범위 기반 반복문: Go 언어에서는 범위(range) 기반 반복문을 제공합니다. 범위 기반 반복문은 컬렉션(배열, 슬라이스, 맵 등)의 요소를 하나씩 반복하면서 메모리 사용을 최적화합니다. 반복문 내에서 별도의 인덱스 변수를 사용하지 않으며, 컬렉션의 요소를 순차적으로 참조하여 반복합니다.

### 배열은 연속된 메모리 -p.242

배열 선언과 함께 컴퓨터는 연속된 메모리 공간을 확보


📌 요소 위치 계산식<br>
	배열 시작 주소 + (인덱스 x 타입 크기)




📌 배열의 크기<br>
타입 크기 x 항목 개수
[ex] [2][3][5]int = 2 * 5* 8 = 80



### 구조체란?- p.254

여러 필드를 묶어서 하나의 구조체로 만듬, 다른 타입의 값들을 변수 하나로 묶어주는 기능

```go
type 타입명 struct {
	필드명 타입
	...
	필드명 타입

}
```

- 초기화 방법

```go
// 전체 초기화
var house House = House{"서울시 강동구",28 , 9.80, "아파트"}
// 일부 필드 초기화
var house House = House{Size: 28 , Type:"아파트"}
```

### 구조체 안의 구조체 정의시 필드 중복 해결 - p.263

. 한번만 사용하게되면 호출되는 최상단의 구조체의 필드를 호출 
[ex] VIPuser.Level 호출 시 VIPuser의 levelr 호출, User 구조체의 Level 호출 시 VIPuser.User.Level 이라 명시

```go
type User struct {
	Name string
	ID string
	Age int
	Level int	
}

type VIPuser struct {
				User
	Price int
	Level int
}
```

### 메모리 정렬 - p.267

컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬됨 레지스터의 크기에 맞춰 데이터를 정렬 해 놓으면 더욱 효율적으로 데이터를 읽어올 수 있음

### 프로그래밍에서 구조체의 역할 - P.270

- 함수는 관련 코드 블록을 묶어서 응집도를 높이고 재사용성을 증가
- 배열은 같은 타입의 데이터들을 묶어서 응집도를 높임
- 구조체는 관련된 데이터들을 묶어서 응집도를 높이고 재사용성을 증가

<aside>
📌

	1. 단일 책임 원칙(Single Responsibility Principle) 준수: 함수나 메서드는 단일 책임을 가지고 작성되어야 합니다. 한 가지 기능만 수행하고, 응집된 역할을 갖도록 설계해야 합니다. 이를 통해 코드를 이해하기 쉽고 유지보수하기 용이하게 만들 수 있습니다.
	
	2. 모듈화와 패키지 분리: 관련된 기능을 독립적인 패키지로 분리하여 모듈화합니다. 각 패키지는 특정한 목적과 역할을 가지며, 필요한 기능을 제공합니다. 모듈화는 코드의 재사용성을 높이고, 응집된 기능을 가진 패키지를 구성함으로써 코드의 가독성과 유지보수성을 향상시킵니다.

	3. 데이터 구조의 일관성: 관련된 데이터를 동일한 구조로 유지하고, 함께 처리하는 함수나 메서드를 함께 그룹화합니다. 데이터 구조의 일관성을 유지하면 코드의 가독성을 높이고, 관련 기능을 논리적으로 그룹화하여 응집도를 높일 수 있습니다.

	4. 캡슐화와 정보 은닉: 적절한 접근 제어자를 사용하여 데이터와 함수를 캡슐화하고, 외부에서 직접 접근하지 못하도록 합니다. 필요한 기능은 캡슐화된 인터페이스를 통해 제공하여 응집된 동작을 수행하도록 합니다.

	5. 함수와 메서드의 분리: 전체적인 코드 응집도를 높이기 위해 관련 기능을 함수로 분리하고, 필요한 경우 메서드로도 분리합니다. 함수와 메서드는 적절한 위치에 정의하여 응집된 기능을 가지도록 합니다.
</aside>

### 포인터 변수 선언 - p.277

- 선언 방법

```go
var p * int
var a int
p = &a

*p = 20 //포인터 변수 p를 통해 메모리에 할당된 실제 값을 초기화
```

- 왜 쓰나?
    
    변수 대입이나 함수 인수 전달은 항상 값을 복사하기 때문에 많은 메모리 공간을 사용하는 문제와 메모리 공간을 복사할 때 발생하는 성능 문제가 존재
    
    ```go
    package main
    
    import "fmt"
    
    type Data struct {
    	value int
    	data [200]int
    }
    
    func ChageData(arg *Data){
    	arg.value = 999
    	arg.data[100] = 999
    }
    
    func main() {
    	var data Data
    
    	ChangeData(&data)
    
    }
    ```
    


📌 Python의 namespace란?<br>
	파이썬에서의 네임스페이스(Namespace)는 변수와 이름의 매핑을 관리하는 추상적인 개념입니다. 네임스페이스는 변수가 생성되고 접근될 수 있는 범위를 제어하고, 이름 충돌을 방지하기 위해 사용됩니다.

	1. 글로벌 네임스페이스 (Global Namespace): 모듈 수준에서 정의된 변수와 함수가 속하는 네임스페이스입니다. 전역적으로 접근 가능하며, 모듈 내에서 정의된 변수와 함수는 이 네임스페이스에 속합니다.

	2. 로컬 네임스페이스 (Local Namespace): 함수, 메서드 또는 클래스의 정의 내에서 사용되는 네임스페이스입니다. 로컬 네임스페이스는 해당 함수 또는 메서드가 호출될 때 생성되고, 함수 실행이 완료되면 소멸합니다.

	3. 빌트인 네임스페이스 (Built-in Namespace): 파이썬 인터프리터가 기본적으로 제공하는 내장 함수와 예약어가 속하는 네임스페이스입니다. 예를 들어, **`print()`** 함수나 **`len()`** 함수는 빌트인 네임스페이스에 속해 있습니다.



### 탈출 검사 - p.289

특정 변수의 인스턴스가 함수외부로 공개되는 것을 분석해내서 스택메모리가 아닌 힙 메모리에 할당하게되는 것


📌 스택 메모리와 힙메모리

	1. 스택 메모리:
		- 스택 메모리는 함수 호출과 관련된 데이터를 저장하는 데 사용됩니다.
		- 함수 호출 시에 로컬 변수, 매개변수, 리턴 주소 등이 스택 메모리에 저장됩니다.
		- 스택은 후입선출(LIFO: Last-In, First-Out)의 구조를 가지며, 함수가 호출될 때마다 새로운 프레임이 스택의 맨 위에 추가됩니다.
		- 함수가 반환되면 해당 프레임이 스택에서 제거되어 메모리가 해제됩니다.
		- 스택 메모리는 크기가 제한적이며, 상대적으로 빠른 액세스 시간을 가지고 있습니다.
		- 스택은 자동으로 관리되기 때문에 개발자가 명시적으로 메모리를 할당하거나 해제할 필요가 없습니다.

	2. 힙 메모리:
		- 힙 메모리는 동적으로 할당되는 데이터를 저장하는 데 사용됩니다.
		- 힙 메모리는 개발자가 직접 관리해야 하며, 메모리 할당과 해제를 명시적으로 수행해야 합니다.
		- 힙은 프로그램 실행 중에 동적으로 크기가 변경될 수 있으며, 데이터는 임의의 순서로 저장됩니다.
		- 힙은 객체, 배열, 구조체 등의 동적으로 생성된 데이터를 저장하는 데 사용됩니다.
		- 힙 메모리는 스택보다 크기가 크고, 액세스하는 데 걸리는 시간도 더 오래 걸립니다.
		- 힙 메모리는 명시적으로 할당 및 해제되어야 하며, 해제되지 않은 메모리는 메모리 누수(Memory Leak)로 이어질 수 있습니다.


### 문자열 비교는 앞글자 부터 대소를 비교 - p.306

**문자열 비교는 앞글자 부터 대소를 판별하여 비교**
‘BBB’와 ‘aaaAAA’ 대소 비교를 할 때 ‘B’의 UTF-8 값이 66번 ‘a’ UTF-9값이 97번이기에 ‘BBB’ >’aaaaAAA’의 값은 false

### 문자열 불변의 법칙 -p.310

1) 문자열은 내부의 문자열 일부만 변경할 수 없다

2) 문자열 요소를 변경하기위해 슬라이스 타입으로 변경할 경우 새로운 메모리에 할당된다

→ 불변의 법칙을 지키기 위해

→ string 합 연산은 불변의 법칙을 지치키위해 연산마다 새로운 메모리에 할당 

→ 연산이 잦을 경우 strings 패키지의 Builder를 사용하여 메모리 낭비 제어

- 불변 원칙을 지키는 이유
    
    예상치 못하는 버그를 방지하기 위해
    

### 패키지 - p321

| 종류 | 설명 |
| --- | --- |
| main 패키지 | 프로그램 시작점을 포함한 패키지 |
| 그 외 패키지 | 메인 페키지르 ㄹ제외한 다른 패키지 내용 |
| 유용힌 패키지 | 새로 만들기 전 제공하는 표준 패키지가 있는지 확인 |
- 모듈 명령어

| 명령어 | 설명 |
| --- | --- |
| go mod init [패키지명]  | go build를 하기위해 go.mod와 go.sum 파일을 생성하여 모듈을 만들기 위한 기초 작업 진행 |
| go mod tidy | go module 패키지를 찾아와서 다운로드, go.mod 파일과 go.sum 파일에 갱신 |